'use strict';

var gm = gm || {};

function main() {
	initPIXI();
	init();
}
function initPIXI() {
	gm.app = new PIXI.Application(gm.settings.data.canvasSize.width, gm.settings.data.canvasSize.height, { antialias: true });
	document.body.appendChild(gm.app.view);

	createjs.Ticker.setFPS(60);

	gm.app.stage.interactive = true;

	gm.settings.fitCanvasToScreen();

	gm.scene.init();

	//gm.tests.pixiDefaults();
	//gm.tests.pixiProjections();
	//gm.tests.textureMesh();
}
function init() {
	window.addEventListener('resize', function (event) {
		gm.settings.fitCanvasToScreen();
	});
}
"use strict";

var gm = gm || {};
gm.settings = {};
gm.settings.data = {};

(function () {
	var stt = gm.settings;

	stt.data.canvasSize = {
		width: 1280,
		height: 720
	};

	stt.fitCanvasToScreen = function () {
		var ws = window.innerWidth / stt.data.canvasSize.width;
		var hs = window.innerHeight / stt.data.canvasSize.height;
		var refs = 1;

		refs = ws < hs ? ws : hs;

		var w = (stt.data.canvasSize.width * refs).toFixed(2);
		var h = (stt.data.canvasSize.height * refs).toFixed(2);
		gm.app.view.style.width = w + "px";
		gm.app.view.style.height = h + "px";

		gm.app.view.style.marginLeft = (window.innerWidth - w) / 2 + "px";
		gm.app.view.style.marginTop = (window.innerHeight - h) / 2 + "px";
	};
})();
'use strict';

var gm = gm || {};
gm.tests = {};

(function () {
	gm.tests.pixiDefaults = function () {
		//simple sprite
		var panda = PIXI.Sprite.fromImage('res/panda.png');
		panda.texture.frame = new PIXI.Rectangle(0, 0, 100, 100);
		gm.app.stage.addChild(panda);
	};
	gm.tests.pixiProjections = function () {
		//projection
		for (var i = 0; i < 10; i++) {
			var item = new TableItem(new PIXI.Texture.fromImage("res/panda.png"), { stands: Math.random() > 0.5 });
			item.position.set(-gm.app.screen.width * Math.random(), -gm.app.screen.height * Math.random());
			gm.scene.projectionRoot.addChild(item);
		}
	};
	function createTextureMesh() {
		var strip = new BaseGhost(PIXI.Texture.fromImage('res/snake.png'));
		gm.scene.root.addChild(strip);
		strip.y = 0;
		strip.x = 0;
		strip.tint = 0xFFFFFF * Math.random();
		strip.scale.set(0.3);
		strip.moveTo(gm.app.screen.width / 2 * randfRange(0.9, 1.1), gm.app.screen.height / 1.5 * randfRange(0.9, 1.1));
	}
	gm.tests.textureMesh = function () {
		for (var i = 0; i < 3; i++) {
			createTextureMesh();
		}
	};
	gm.tests.ghostAvatar = function () {
		var g = new GhostAvatar("res/ghosts/spirit_sprites.json");
		gm.app.stage.addChild(g);
	};
	gm.tests.bitmapText = function () {
		var bitmapText = new PIXI.extras.BitmapText("text using a fancy font!", { font: "35px digital-regular", align: "right" });
		gm.scene.root.addChild(bitmapText);
	};
})();
"use strict";

/**
 *@method randi
 *@param {Number} val1 Max generated value or min value if val2 defined
 *@param {Number} val2 Max generated value or undefined
 *@return {Number} Nonfractional [0, val1] or [val1, val2]
 */
function randi(val1, val2) {
  if (val2 == undefined) return Math.round(Math.random() * val1);else return randiRange(val1, val2);
}

function randiRange(min, max) {
  return Math.round(Math.random() * (max - min) + min);
}
/**
 *@method randf
 *@param {Number} max Max generated value
 *@return {Number} Fractional [0, max]
 */
function randf(max) {
  return Math.random() * max;
}

function randfRange(min, max) {
  return Math.random() * (max - min) + min;
}

/**
 * @brief random element from array
 *
 * @Param array inpu array
 *
 * @Returns empty array if input array empty or not array; or rand element if not
 */
function randElem(array) {
  if (array && array.length && (Array.isArray(array) || "string")) return array[randi(array.length - 1)];else return null;
}

Math.lerp = function (from, to, weight) {
  var mu2;

  mu2 = (1 - Math.cos(weight * Math.PI)) / 2;
  return from * (1 - mu2) + to * mu2;
};

Number.prototype.clamp = function (min, max) {
  return Math.min(Math.max(this, min), max);
};

function CosineInterpolate(y1, y2, mu) {
  var mu2;
  mu2 = (1 - Math.cos(mu * Math.PI)) / 2;
  return y1 * (1 - mu2) + y2 * mu2;
}
function LinearInterpolate(y1, y2, mu) {
  return y1 * (1 - mu) + y2 * mu;
}
String.prototype.replaceAt = function (index, replacement) {
  return this.substr(0, index) + replacement + this.substr(index + replacement.length);
};

function calculateDifferenceBetweenAngles(firstAngle, secondAngle) {
  var difference = secondAngle - firstAngle;
  while (difference < -Math.PI) {
    difference += Math.PI * 2;
  }while (difference > Math.PI) {
    difference -= Math.PI * 2;
  }return difference;
}
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TableItem = function () {
	var defaultProps = {
		stands: false,
		movable: true
	};
	return function (_PIXI$projection$Cont) {
		_inherits(_class, _PIXI$projection$Cont);

		function _class(texture, props) {
			_classCallCheck(this, _class);

			//set props
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_class).call(this));

			props = props || defaultProps;
			for (var i in defaultProps) {
				if (props[i] != undefined) continue;

				props[i] = defaultProps[i];
			}

			if (texture) {
				var image = new PIXI.projection.Sprite2d(texture);
				image.anchor.set(0.5, props.stands ? 1.0 : 0);
				_this.addChild(image);
				_this.image = image;
			}

			_this.proj.affine = props.stands ? PIXI.projection.AFFINE.AXIS_X : PIXI.projection.AFFINE.NONE;;
			if (props.movable) _this.addInteraction();
			return _this;
		}

		_createClass(_class, [{
			key: 'addInteraction',
			value: function addInteraction() {
				this.interactive = true;
				this.on('pointerdown', this.onDragStart).on('pointerup', this.onDragEnd).on('pointerupoutside', this.onDragEnd).on('pointermove', this.onDragMove);
			}
		}, {
			key: 'snap',
			value: function snap() {
				this.position.x = Math.min(Math.max(this.position.x, -gm.app.screen.width), gm.app.screen.width);
				this.position.y = Math.min(Math.max(this.position.y, -gm.app.screen.height + 10), 10);
				this.scale.x = 1;
				this.scale.y = 1;

				if (this.onDrag) requestAnimationFrame(this.onDrag);
			}
		}, {
			key: 'onDragStart',
			value: function onDragStart(event) {
				var obj = event.currentTarget;
				obj.dragData = event.data;
				obj.dragging = 1;
				obj.dragPointerStart = event.data.getLocalPosition(obj.parent);
				obj.dragObjStart = new PIXI.Point();
				obj.dragObjStart.copy(obj.position);
				obj.dragGlobalStart = new PIXI.Point();
				obj.dragGlobalStart.copy(event.data.global);
				obj.scale.x = 1.1;
				obj.scale.y = 1.1;
				event.stopPropagation();

				obj.parent.setChildIndex(obj, obj.parent.children.length - 1);
			}
		}, {
			key: 'onDragEnd',
			value: function onDragEnd(event) {
				var obj = event.currentTarget;
				if (!obj.dragging) return;
				if (obj.dragging == 1) {
					if (obj.onUserInteract) obj.onUserInteract();
				} else this.snap(obj);

				obj.dragging = 0;
				obj.dragData = null;

				event.stopPropagation();
				// set the interaction data to null
			}
		}, {
			key: 'onDragMove',
			value: function onDragMove(event) {
				var obj = event.currentTarget;
				if (!obj.dragging) return;
				event.stopPropagation();
				var data = obj.dragData; // it can be different pointer!
				if (obj.dragging == 1) {
					// click or drag?
					if (Math.abs(data.global.x - obj.dragGlobalStart.x) + Math.abs(data.global.y - obj.dragGlobalStart.y) >= 3) {
						// DRAG
						obj.dragging = 2;
					}
				}
				if (obj.dragging == 2) {
					var dragPointerEnd = data.getLocalPosition(obj.parent);
					// DRAG
					obj.position.set(obj.dragObjStart.x + (dragPointerEnd.x - obj.dragPointerStart.x), obj.dragObjStart.y + (dragPointerEnd.y - obj.dragPointerStart.y));
					obj.position.x = Math.min(Math.max(obj.position.x, -gm.app.screen.width), gm.app.screen.width);
					obj.position.y = Math.min(Math.max(obj.position.y, -gm.app.screen.height + 10), 10);
					if (obj.onDrag) obj.onDrag();

					//set depth
					var selfy = obj.position.y;
					var selfindex = obj.parent.getChildIndex(obj);
					if (selfindex > 1) {
						var other = obj.parent.getChildAt(selfindex - 1);
						var othery = other.position.y;
						if (selfy < othery) obj.parent.setChildIndex(obj, selfindex - 1);
					}
					if (selfindex < obj.parent.children.length - 1) {
						var other = obj.parent.getChildAt(selfindex + 1);
						var othery = other.position.y;
						if (selfy > othery) obj.parent.setChildIndex(obj, selfindex + 1);
					}
				}
			}
		}]);

		return _class;
	}(PIXI.projection.Container2d);
}();
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CrystalPortal = function () {
	var crystalShift = 250;
	return function (_TableItem) {
		_inherits(_class, _TableItem);

		function _class() {
			_classCallCheck(this, _class);

			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_class).call(this, new PIXI.Texture.fromImage("res/table_stuff/spirit_pentagram.png"), { stands: true, movable: false }));

			_this.initCrystal();
			_this.allowTeleport = true;
			_this.snap();
			_this.addRopes();
			_this.addInteraction();
			return _this;
		}

		_createClass(_class, [{
			key: "initCrystal",
			value: function initCrystal() {
				var self = this;
				function makeGlitching() {
					var str = self.glitchSrt;
					splitfilter.uniforms.red[0] = randiRange(-str, str);
					splitfilter.uniforms.red[1] = randiRange(-str, str);

					splitfilter.uniforms.green[0] = randiRange(-str, str);
					splitfilter.uniforms.green[1] = randiRange(-str, str);

					splitfilter.uniforms.blue[0] = randiRange(-str, str);
					splitfilter.uniforms.blue[1] = randiRange(-str, str);
				}

				this.glitchSrt = 0;
				var splitfilter = new PIXI.filters.RGBSplitFilter();
				this.image.filters = [splitfilter];
				setInterval(makeGlitching, 100);

				var crystal = new PIXI.projection.Sprite2d(new PIXI.Texture.fromImage("res/table_stuff/spirit_crystal.png"));
				crystal.anchor.set(0.5, 1);
				crystal.y -= 70;
				crystal.x -= 20;
				crystal.scale.set(2);
				crystal.filters = [splitfilter];
				this.addChild(crystal);
				this.crystal = crystal;

				createjs.Tween.get(crystal, { loop: true }).to({ y: -90 }, 3000, createjs.Ease.quadInOut).to({ y: -70 }, 3000, createjs.Ease.quadInOut);

				makeGlitching(); //do once to discard
			}
		}, {
			key: "addInteraction",
			value: function addInteraction() {
				this.interactive = true;
				this.on('pointermove', this.handleGhosts).on('pointerdown', this.sendGhost);
			}
		}, {
			key: "addRopes",
			value: function addRopes() {
				var pivotContainer = new PIXI.Container();
				pivotContainer.alpha = 0;
				pivotContainer.name = "ropes_pivot";
				this.addChildAt(pivotContainer, 1);
				pivotContainer.y -= crystalShift + 70;
				pivotContainer.x -= 20;

				var ropesContainer = new PIXI.Container();
				this.ropesContainer = ropesContainer;
				pivotContainer.addChild(ropesContainer);

				this.teleportDirections = [];

				var ray = new PIXI.Sprite(new PIXI.Texture.fromImage("res/effects/ray.png"));
				ray.anchor.set(0, 0.5);
				ray.scale.x = 5;
				ray.alpha = 0.7;
				pivotContainer.addChild(ray);
				ray.blendMode = PIXI.BLEND_MODES.ADD;
				this.highlightRopesRay = ray;

				var self = this;
				function add(index) {
					// build a rope!
					var ropeLength = 45;

					var points = [];

					for (var i = 0; i < 25; i++) {
						points.push(new PIXI.Point(i * ropeLength, 0));
					}

					var rope = new PIXI.mesh.Rope(PIXI.Texture.fromImage('res/rope.png'), points);
					rope.rotation = Math.PI * 2 * (index / gm.play.boilers) + randfRange(-Math.PI * 0.1, Math.PI * 0.1);
					//rope.rotation = Math.PI*2*(index/gm.play.boilers);

					self.teleportDirections.push(rope.rotation);
					rope.scale.y = 0.5;
					rope.blendMode = PIXI.BLEND_MODES.ADD;
					ropesContainer.addChild(rope);

					// start animating
					var count = randf(10);
					gm.app.ticker.add(function () {
						count += randfRange(0.01, 0.05);

						// make the snake
						for (var i = 0; i < points.length; i++) {
							var lfactor = i / points.length;
							points[i].y = Math.sin(i * 0.5 + count) * 50 * lfactor;
							points[i].x = i * ropeLength + Math.cos(i * 0.3 + count) * 30 * lfactor;
						}
					});
				}

				for (var i = 0; i < gm.play.boilers; i++) {
					add(i);
				}console.log(this.teleportDirections);
			}
		}, {
			key: "allowTransfer",
			value: function allowTransfer(ghost) {
				this.allowTeleport = false; //do not accept new ghosts

				createjs.Tween.get(this.getChildByName("ropes_pivot"), { loop: false }).to({ alpha: 1 }, 1000, createjs.Ease.quartInOut);
				this.glitchSrt = 4;
				this.containsGhost = ghost;
			}
		}, {
			key: "sendGhost",
			value: function sendGhost() {
				if (!this.containsGhost) return;

				createjs.Tween.get(this.highlightRopesRay, { loop: false }).to({ alpha: 1 }, 50, createjs.Ease.quartInOut).to({ alpha: 0.7 }, 600, createjs.Ease.quartInOut); //just return for next animation

				//scale in another tween
				createjs.Tween.get(this.highlightRopesRay.scale, { loop: false }).to({ x: 7, y: 2 }, 100, createjs.Ease.quadOut).to({ x: 5, y: 1 }, 1000, createjs.Ease.quintIn); //just return for next animation

				this.allowTeleport = true; //do not accept new ghosts

				createjs.Tween.get(this.getChildByName("ropes_pivot"), { loop: false }).to({ alpha: 0 }, 2000, createjs.Ease.quartInOut);
				this.glitchSrt = 0;
				this.containsGhost = null;
			}
		}, {
			key: "handleGhosts",
			value: function handleGhosts(event) {
				if (gm.activeGhost && this.allowTeleport && this.crystal.getBounds().contains(event.data.global.x, event.data.global.y)) {
					gm.activeGhost.interactive = false;
					gm.activeGhost.vanishInPoint = true;
					gm.activeGhost.moveToAbsolute(this.worldTransform.tx, this.worldTransform.ty - 250);

					createjs.Tween.get(gm.activeGhost, { loop: false }).to({ alpha: 0 }, 2000, createjs.Ease.quartInOut);

					this.allowTransfer(gm.activeGhost);

					gm.activeGhost = null;
				} else if (this.containsGhost) {
					var rotate = function rotate(p, theta) {
						var xtemp = p.x;
						p.x = p.x * Math.cos(theta) - p.y * Math.sin(theta);
						p.y = xtemp * Math.sin(theta) + p.y * Math.cos(theta);
					};

					var mousepos = event.data.global;
					var thispos = new PIXI.Point(this.worldTransform.tx, this.worldTransform.ty - crystalShift);
					var dir = new PIXI.Point(mousepos.x - thispos.x, thispos.y - mousepos.y);

					;

					rotate(dir, Math.PI / 2);

					var angle = Math.atan2(dir.x, dir.y);

					var nearest = 0;
					var _nearestVal = 999;
					for (var i in this.teleportDirections) {
						var value = calculateDifferenceBetweenAngles(angle + Math.PI / 2 + Math.PI / 4, this.teleportDirections[i]);
						if (value < _nearestVal) {
							nearest = i;
							_nearestVal = value;
						}
					}

					for (var i in this.ropesContainer.children) {
						var rope = this.ropesContainer.children[i];
						if (i != nearest) rope.tint = 0xFFFFFF;else {
							rope.tint = 0xFFBBBB;
							this.highlightRopesRay.rotation = rope.rotation;
						}
					}
				}
			}
		}]);

		return _class;
	}(TableItem);
}();
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CornerPaper = function () {
	var shiftTime = 700;
	return function (_PIXI$Sprite) {
		_inherits(_class, _PIXI$Sprite);

		function _class(props) {
			_classCallCheck(this, _class);

			var variants = [];
			for (var i = 0; i <= 3; i++) {
				variants.push("res/papers/variant" + i + ".png");
			}
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_class).call(this, new PIXI.Texture.fromImage(randElem(variants))));

			_this.state = 3;
			//0: in corner
			//1: moving
			//2: in center
			//3: hidden

			_this.cornerPos = {
				x: gm.app.screen.width,
				y: gm.app.screen.height,
				rotation: Math.PI / 10 - Math.PI / 14 * gm.scene.cornerPapers.root.children.length,
				alpha: 1
			};
			_this.anchor.set(0.5);
			_this.position.set(gm.app.screen.width * 2, gm.app.screen.height * 2);
			_this.toggleCornerShow();

			_this.addInteraction();
			return _this;
		}

		_createClass(_class, [{
			key: "removeFromGame",
			value: function removeFromGame() {
				var _this2 = this;

				createjs.Tween.get(this, { loop: false, override: true }).to({ x: gm.app.screen.width * 2, y: gm.app.screen.height * 2, alpha: 0, rotation: Math.PI / 2 }, shiftTime, createjs.Ease.quartInOut).call(function () {
					return _this2.parent.removeChild(_this2);
				});
			}
		}, {
			key: "toggleCornerShow",
			value: function toggleCornerShow() {
				var _this3 = this;

				var waitID = setInterval(function () {
					if (_this3.state == 0 || _this3.state == 2) {
						_this3.state = 1;
						clearInterval(waitID);

						createjs.Tween.get(_this3, { loop: false }).to({ x: gm.app.screen.width * 2, y: gm.app.screen.height * 2, alpha: 0, rotation: Math.PI / 2 }, shiftTime, createjs.Ease.quartInOut).call(function () {
							return _this3.state = 3;
						});
					} else if (_this3.state == 3) {
						_this3.state = 1;
						clearInterval(waitID);
						createjs.Tween.get(_this3, { loop: false }).to(_this3.cornerPos, shiftTime, createjs.Ease.quartInOut).call(function () {
							return _this3.state = 0;
						});
					}
				}, 33);
			}
		}, {
			key: "addInteraction",
			value: function addInteraction() {
				this.interactive = true;
				this.on('pointerdown', this.onClick);
			}
		}, {
			key: "putForward",
			value: function putForward() {
				this.parent.setChildIndex(this, this.parent.children.length - 1);
			}
		}, {
			key: "onClick",
			value: function onClick(event) {
				var _this4 = this;

				var obj = event.currentTarget;

				if (this.state == 0) {
					this.state = 1;

					createjs.Tween.get(obj, { loop: false }).to({ x: gm.app.screen.width / 2, y: gm.app.screen.height / 2, rotation: randfRange(-0.1, 0.1) }, shiftTime, createjs.Ease.quartInOut).call(function () {
						return _this4.state = 2;
					});

					this.putForward();
				} else if (this.state == 2) {
					this.state = 1;
					createjs.Tween.get(obj, { loop: false }).to(obj.cornerPos, shiftTime, createjs.Ease.quartInOut).call(function () {
						return _this4.state = 0;
					});
				}
			}
		}]);

		return _class;
	}(PIXI.Sprite);
}();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseGhost = function () {
	// build a rope!
	var ropeLength = 20;
	var widthLimit = 150;
	var heightLimit = 50;

	var refLength = 0.13; //"Scale" factor in update.sin()

	return function (_PIXI$Container) {
		_inherits(_class, _PIXI$Container);

		function _class(config) {
			_classCallCheck(this, _class);

			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_class).call(this));

			var points = [];

			for (var i = 0; i < 25; i++) {
				points.push(new PIXI.Point(i * ropeLength, 0));
			}

			_this.randSeed = randi(999999);
			_this.color = randfRange(0.5, 1) * 0xFFFFFF;

			var rowbody = gm.utils.loadCoa_tools_faces(config, { color: _this.color, seed: _this.randSeed }, function () {
				rowbody.cacheAsBitmap = true;
				var texture = gm.app.renderer.generateTexture(rowbody);
				var body = new PIXI.mesh.Rope(texture, points);
				body.blendMode = PIXI.BLEND_MODES.ADD;
				body.y = rowbody.getBounds().height - 50;
				_this.addChild(body);

				/*
    {
    	var item = new PIXI.Sprite(texture);
    	item.anchor.set(0, 0);
    	item.y -= rowbody.getBounds().height-50;
    	gm.scene.root.addChild(item);
    }
    */
			});

			_this.points = points;
			_this.moveSpeed = randfRange(0.02, 0.05);

			_this.widthLimit = widthLimit * randfRange(0.5, 1.2);
			_this.heightLimit = heightLimit * randfRange(0.5, 1.2);
			_this.timeRotateFactor = 0.1;

			_this.count = randf(10);
			_this.targetPoint = { x: 0, y: 0 };
			_this.leadingPoint = _this.points.length;
			_this.vanishInPoint = false;

			_this.addLinkedPaper();

			gm.app.ticker.add(function (dt) {
				return _this.update(dt);
			});
			return _this;
		}

		_createClass(_class, [{
			key: 'addLinkedPaper',
			value: function addLinkedPaper() {
				this.linkPaper = gm.scene.cornerPapers.addNew();
				var g = new GhostAvatar("res/ghosts/avatars/spirit_sprites.json", { color: this.color, seed: this.randSeed });
				g.scale.set(0.7);
				g.position.set(-200, -300);
				this.linkPaper.addChild(g);
			}
		}, {
			key: 'moveToAbsolute',
			value: function moveToAbsolute(x, y, onTargetReached) {
				this.moveTo((x - this.position.x) / this.scale.x, (y - this.position.y) / this.scale.y, onTargetReached);
			}
		}, {
			key: 'moveTo',
			value: function moveTo(x, y, onTargetReached) {
				this.targetPoint = { x: x, y: y };
				this.moveToPoint = true;

				this.leadingPoint = 1;
				//single-fires event
				this.onTargetReached = onTargetReached;
			}
		}, {
			key: 'update',
			value: function update(dt) {
				var plgh = this.points.length;
				this.count += this.moveSpeed;

				if (this.moveToPoint) {
					this.points[plgh - this.leadingPoint].x = LinearInterpolate(this.points[plgh - this.leadingPoint].x, this.targetPoint.x, 0.1);
					this.points[plgh - this.leadingPoint].y = LinearInterpolate(this.points[plgh - this.leadingPoint].y, this.targetPoint.y, 0.1);

					for (var i = plgh - 1 - this.leadingPoint; i >= 0; i--) {
						this.points[i].x = LinearInterpolate(this.points[i].x, this.points[i + 1].x, 0.5);
						this.points[i].y = LinearInterpolate(this.points[i].y, this.points[i + 1].y, 0.5);
					}

					if (Math.abs(this.points[plgh - this.leadingPoint].x - this.targetPoint.x) < 10 && Math.abs(this.points[plgh - this.leadingPoint].y - this.targetPoint.y) < 10) {

						if (!this.vanishInPoint) this.leadingPoint++;

						if (this.leadingPoint == plgh) {
							this.moveToPoint = false;
							this.leadingPoint++; //remove last point from lerp list

							if (this.onTargetReached) {
								this.onTargetReached();
								this.onTargetReached = null;
							}
						}
					}
				}

				// make the snake
				for (var i = plgh - 1; i > plgh - this.leadingPoint; i--) {
					this.points[i].x = LinearInterpolate(this.points[i].x, Math.sin(i * refLength + this.count) * Math.cos(this.count * this.timeRotateFactor) * this.widthLimit + this.targetPoint.x, 0.1);
					this.points[i].y = LinearInterpolate(this.points[i].y, Math.cos(i * refLength + this.count) * Math.sin(this.count * this.timeRotateFactor) * this.heightLimit + this.targetPoint.y, 0.1);
				}
			}
		}, {
			key: 'enableDebug',
			value: function enableDebug() {
				var g = new PIXI.Graphics();
				this.parent.addChild(g);

				gm.app.ticker.add(renderPoints);

				function renderPoints() {
					g.clear();

					g.lineStyle(2, 0xffc2c2);
					g.moveTo(this.points[0].x, this.points[0].y);

					for (var i = 1; i < plgh; i++) {
						g.lineTo(this.points[i].x, this.points[i].y);
					}

					for (var i = 1; i < plgh; i++) {
						g.beginFill(0xff0022);
						g.drawCircle(this.points[i].x, this.points[i].y, 10);
						g.endFill();
					}
				}
			}
		}, {
			key: 'addInteraction',
			value: function addInteraction() {
				this.interactive = true;
				this.on('pointerdown', this.onDragStart).on('pointerup', this.onDragEnd).on('pointerupoutside', this.onDragEnd).on('pointermove', this.onDragMove);
			}
		}, {
			key: 'onDragStart',
			value: function onDragStart(event) {
				var obj = event.currentTarget;
				obj.dragData = event.data;
				obj.dragging = 1;
				obj.dragPointerStart = event.data.getLocalPosition(obj.parent);
				obj.dragObjStart = new PIXI.Point();
				obj.dragObjStart.copy(obj.position);
				obj.dragGlobalStart = new PIXI.Point();
				obj.dragGlobalStart.copy(event.data.global);
				event.stopPropagation();
				obj.linkPaper.putForward();

				gm.activeGhost = obj;
			}
		}, {
			key: 'onDragEnd',
			value: function onDragEnd(event) {
				var obj = event.currentTarget;
				if (!obj.dragging) return;
				if (obj.dragging == 1) if (obj.onUserInteract) obj.onUserInteract();

				obj.dragging = 0;
				obj.dragData = null;

				event.stopPropagation();
				// set the interaction data to null
				gm.activeGhost = null;
			}
		}, {
			key: 'onDragMove',
			value: function onDragMove(event) {
				var obj = event.currentTarget;
				if (!obj.dragging) return;
				var data = obj.dragData; // it can be different pointer!
				if (obj.dragging == 1) {
					// click or drag?
					if (Math.abs(data.global.x - obj.dragGlobalStart.x) + Math.abs(data.global.y - obj.dragGlobalStart.y) >= 3) {
						// DRAG
						obj.dragging = 2;
					}
				}
				if (obj.dragging == 2) {
					var dragPointerEnd = data.getLocalPosition(obj.parent);
					obj.moveToAbsolute(dragPointerEnd.x, dragPointerEnd.y);
					if (obj.onDrag) obj.onDrag();
				}
			}
		}]);

		return _class;
	}(PIXI.Container);
}();
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GhostAvatar = function () {
	return function (_PIXI$Container) {
		_inherits(_class, _PIXI$Container);

		function _class(config, params) {
			_classCallCheck(this, _class);

			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_class).call(this));

			var graphics = new PIXI.Graphics();
			_this.addChild(graphics);
			graphics.lineStyle(2, 0x222222, 1);
			graphics.beginFill(0x000000, 0.1);
			graphics.drawRoundedRect(50, 50, 230, 350, 2);

			var avatar = gm.utils.loadCoa_tools_faces(config, { color: params.color, seed: params.seed });
			avatar.scale.set(0.78);
			avatar.x -= 20;
			_this.addChild(avatar);
			return _this;
		}

		return _class;
	}(PIXI.Container);
}();
"use strict";

var gm = gm || {};
gm.scene = {};

(function () {
	function initTableStuff() {
		{
			var item = new CrystalPortal();
			item.position.set(0, -500);
			item.snap();
			item.scale.set(1.3);
			gm.scene.projectionRoot.addChild(item);
		}
		{
			(function () {
				var item = new TableItem(new PIXI.Texture.fromImage("res/table_stuff/spirit_clock.png"), { stands: true, movable: true });
				item.position.set(-gm.app.screen.width * Math.random(), -500);
				item.snap();
				gm.scene.projectionRoot.addChild(item);

				var timeString = "00000";

				var bitmapText = new PIXI.extras.BitmapText(timeString, { font: "75px digital-regular", align: "center" });
				item.addChild(bitmapText);
				bitmapText.y -= 150;
				bitmapText.x -= 100;

				setInterval(function () {
					var sample = "1234 567890!@#$%^&*()p87gBSAlpfkpЁ!";
					timeString = timeString.replaceAt(randi(timeString.length - 1), randElem(sample));
					bitmapText.text = timeString;
				}, 1000);
			})();
		}
		{
			(function () {
				var item = new TableItem(new PIXI.Texture.fromImage("res/table_stuff/spirit_jar.png"), { stands: true });
				item.position.set(gm.app.screen.width * randfRange(0.3, 0.5), -200);
				item.snap();
				item.image.anchor.y = 0.8;
				item.tint = 0xCCCCFF;
				item.ghosts = [];
				gm.scene.ghostStorage = item;
				gm.scene.projectionRoot.addChild(item);
				item.onDrag = function () {
					for (var i in item.ghosts) {
						var g = item.ghosts[i];
						if (!g._original_scale) g._original_scale = g.scale.x;

						var trfm = gm.scene.ghostStorage.worldTransform;
						g.x = trfm.tx;
						g.y = trfm.ty;

						g.scale.set(trfm.a * g._original_scale);
					}
				};
				item.onUserInteract = function () {
					var g = item.ghosts.shift();
					if (!g) return;
					g.moveTo(0, -700 / g.scale.x * item.scale.x);
					setTimeout(function () {
						g.moveToAbsolute(gm.app.screen.width * randfRange(0.4, 0.6), gm.app.screen.height * randfRange(0.7, 0.9));
						g.heightLimit = g.widthLimit;
						g.addInteraction();
					}, 200);
				};
			})();
		}

		{
			var item = new TableItem(new PIXI.Texture.fromImage("res/table_stuff/spirit_numbers.png"), { stands: false, movable: false });
			item.position.set(-gm.app.screen.width / 2, -400);
			item.image.scale.x = -1;
			gm.scene.projectionRoot.addChild(item);

			var score = ("" + gm.play.score).padStart(6, "0");
			var bitmapText = new PIXI.extras.BitmapText(score, { font: "70px digital-regular", align: "left" });
			item.addChild(bitmapText);
			bitmapText.y += 185;
			bitmapText.x -= 130;
		}

		{
			var item = new TableItem(new PIXI.Texture.fromImage("res/table_stuff/spirit_frame.png"), { stands: true, movable: true });
			item.position.set(-gm.app.screen.width * Math.random(), -500);
			item.snap();
			gm.scene.projectionRoot.addChild(item);
		}
	}
	function initTable() {
		// create a new Sprite from an image path
		var container = new PIXI.projection.Container2d();
		container.position.set(gm.app.screen.width / 2, gm.app.screen.height);

		//TODO: remove
		var squareFar = new PIXI.Sprite(PIXI.Texture.WHITE);
		squareFar.tint = 0xff0000;
		squareFar.alpha = 0;
		squareFar.factor = 1;
		squareFar.anchor.set(0.5);
		squareFar.position.set(gm.app.screen.width / 2, 50);

		var surface = new PIXI.projection.Sprite2d(new PIXI.Texture.fromImage("res/bkg.jpg"));
		surface.anchor.set(0.5, 1.0);
		//surface.scale.y = -1; //sorry, have to do that to make a correct projection
		surface.width = gm.app.screen.width * 2;
		surface.height = gm.app.screen.height;

		gm.scene.root.addChild(container);
		gm.scene.root.addChild(squareFar);
		container.addChild(surface);
		gm.scene.projectionRoot = container;

		// Listen for animate update
		gm.app.ticker.add(function (delta) {
			// clear the projection
			container.proj.clear();
			container.updateTransform();
			// now we can get local coords for points of perspective
			var pos = container.toLocal(squareFar.position);
			//need to invert this thing, otherwise we'll have to use scale.y=-1 which is not good
			pos.y = -pos.y;
			pos.x = -pos.x;
			container.proj.setAxisY(pos, -squareFar.factor);
		});
	}
	function initCornerPapers() {
		//Без нее мигает)
		var panda = PIXI.Sprite.fromImage('res/panda.png');
		panda.anchor.set(1);
		gm.app.stage.addChild(panda);

		var container = new PIXI.Container();
		gm.scene.root.addChild(container);
		gm.scene.cornerPapers = {};
		gm.scene.cornerPapers.root = container;

		gm.scene.cornerPapers.addNew = function () {
			var item = new CornerPaper();
			container.addChild(item);

			return item;
		};
		gm.scene.cornerPapers.removeAll = function () {
			function rm(index) {
				setTimeout(function () {
					return container.children[index].removeFromGame();
				}, randf(100));
			}
			for (var i in container.children) {
				rm(i);
			}
		};
	}
	function initEnvironment() {
		function addLamp(where, scale) {
			{
				var item = new PIXI.Sprite(new PIXI.Texture.fromImage("res/spirit_bulb.png"));
				item.anchor.set(0.5, 0);
				item.x = gm.app.screen.width * where;
				item.scale.set(scale);
				gm.scene.root.addChildAt(item, 0);

				createjs.Tween.get(item, { loop: true }).to({ rotation: Math.PI * randfRange(-0.02, 0.02) }, randiRange(2000, 5000), createjs.Ease.quadInOut).to({ rotation: 0 }, randiRange(2000, 5000), createjs.Ease.quadInOut);
			}

			//light
			{
				var item = new PIXI.Sprite(new PIXI.Texture.fromImage("res/effects/pump_flare_0" + randiRange(4, 6) + ".png"));
				item.anchor.set(0.5, 0.5);
				item.x = gm.app.screen.width * where;
				item.y = 400 * scale;
				item.scale.set(20 * scale);
				item.blendMode = PIXI.BLEND_MODES.SCREEN;
				item.alpha = 0.5;
				item.rotation = Math.PI * 2 * Math.random();
				item.tint = 0xFFDD56;
				gm.scene.root.addChildAt(item, 1);

				createjs.Tween.get(item, { loop: true }).to({ alpha: 0.53 }, randiRange(60, 200), createjs.Ease.linear).to({ alpha: 0.5 }, randiRange(60, 200), createjs.Ease.linear).to({ alpha: 0.47 }, randiRange(60, 200), createjs.Ease.linear);
			}
		}
		addLamp(0.2, 0.25);
		addLamp(0.8, 0.35);
		addLamp(0.55, 0.15);
	}
	function initMain() {
		var container = new PIXI.Container();
		gm.app.stage.addChild(container);

		gm.scene.root = container;
	}
	function initGhosts() {
		for (var i = 0; i < 3; i++) {
			setTimeout(gm.spawnGhost, randf(3000));
		}
	}
	function whaitTillLoad(callback) {
		var waitID = setInterval(function () {
			if (gm.scene.ghostStorage.worldTransform.tx) {
				clearInterval(waitID);
				callback();
			}
		}, 10);
	}
	function load(callback) {
		var loader = new PIXI.loaders.Loader();
		loader.add('fnt', 'res/fonts/digital-regular/digital-regular.fnt');
		loader.load(function (loader, resources) {
			PIXI.loaders.parseBitmapFontData(resources.fnt, new PIXI.Texture.fromImage("res/fonts/digital-regular/digital-regular.png"));
			callback();
		});
	}
	gm.spawnGhost = function () {
		var strip = new BaseGhost("res/ghosts/flow/sprites_flow.json");
		gm.scene._ghostContainer.addChild(strip);

		strip.tint = 0xFFFFFF * Math.random();
		strip.scale.set(randfRange(0.8, 1.2));

		strip.y = gm.scene.ghostStorage.worldTransform.ty;
		strip.x = gm.scene.ghostStorage.worldTransform.tx;

		for (var i in strip.points) {
			strip.points[i].x = 0;
			strip.points[i].y = -10000 - i * 10;
		}

		strip.moveTo(0, randiRange(-150, -50) / strip.scale.x);
		gm.scene.ghostStorage.ghosts.push(strip);
	};
	gm.scene.init = function () {
		load(function () {

			gm.play = {};
			gm.play.score = 666;
			gm.play.boilers = 4;

			initMain();
			initTable();
			initTableStuff();

			initEnvironment();

			whaitTillLoad(function () {
				var container = new PIXI.Container();
				container.filters = [new PIXI.filters.GlowFilter(15, 3, 1, 0xFFFFFF, 0.5)];
				gm.scene._ghostContainer = container;
				gm.scene.root.addChild(container);

				initGhosts();
				initCornerPapers();
			});
		});
	};
})();
'use strict';

var gm = gm || {};
gm.utils = {};

gm.utils.loadCoa_tools_faces = function (config, params, callback) {
	params = params || {};

	var container = new PIXI.Container();

	var loader = new PIXI.loaders.Loader();
	loader.add('config', config);
	loader.load(process);

	var path = config.substring(0, config.lastIndexOf('/') + 1);

	var loads = 0;
	function countLoads() {
		if (++loads == 0 && callback) callback();
	}

	//TODO: Add pure loader
	function addRandomFrom(node, colorize) {
		loads--;
		//(0)
		var texture = new PIXI.Texture.fromImage(path + node.resource_path);

		//(2)
		function addImage() {
			function rand(max, seed) {
				seed = params.seed + seed + 10000;
				seed *= Math.sin(seed) * Math.tan(seed);
				seed = Math.abs(Math.round(seed));

				return seed % max;
			}

			var xframe = rand(node.tiles_x, node.name.length + node.resource_path.length); //Gen random values
			var yframe = rand(node.tiles_y, node.name.length + node.resource_path.length);

			var wframe = texture.baseTexture.realWidth / node.tiles_x;
			var hframe = texture.baseTexture.realHeight / node.tiles_y;
			var rectangle = new PIXI.Rectangle(xframe * wframe, yframe * hframe, wframe, hframe);

			var img = new PIXI.Sprite(new PIXI.Texture(texture, rectangle));
			img.position.set(node.position[0], node.position[1]);
			img.z = node.z;

			if (colorize && params.color) img.tint = params.color;

			//add with sorting
			var added = false;
			for (var i = 0; i < container.children.length; i++) {
				if (container.children[i].z != undefined && img.z <= container.children[i].z) {
					container.addChildAt(img, i);
					added = true;
					break;
				}
			}
			if (!added) container.addChild(img);

			countLoads();
		}

		//(1)
		if (texture.baseTexture.hasLoaded) requestAnimationFrame(addImage);else texture.baseTexture.once('loaded', addImage);
	}

	function process(loader, resources) {
		var frame = {
			x: 0,
			y: 0,
			w: 0,
			h: 0
		};

		var res = resources.config.data.nodes;
		var a_topperSelect = ["horns", "ears", "hats"];
		var topperSelect = a_topperSelect[params.seed % a_topperSelect.length];
		var a_mouthSelect = ["mouth", "mustache"];
		var mouthSelect = a_mouthSelect[params.seed % a_mouthSelect.length];
		var elements = ["base", "eyes", "brows", "emotions", "paws", "glasses"];
		var colorizable = ["base", "ears"];

		for (var i in res) {
			var name = res[i].name.split('.')[0];
			if (name == topperSelect || name == mouthSelect || elements.includes(name)) addRandomFrom(res[i], colorizable.includes(name));
		}
	}

	return container;
};